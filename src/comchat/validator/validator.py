"""
CommuneX example of a Text Validator Module

This module provides an example TextValidator class for validating text generated by modules in subnets.
The TextValidator retrieves module addresses from the subnet, prompts the modules to generate answers to a given question,
and scores the generated answers against the validator's own answers.

Classes:
    TextValidator: A class for validating text generated by modules in a subnet.

Functions:
    set_weights: Blockchain call to set weights for miners based on their scores.
    cut_to_max_allowed_weights: Cut the scores to the maximum allowed weights.
    extract_address: Extract an address from a string.
    get_subnet_netuid: Retrieve the network UID of the subnet.
    get_ip_port: Get the IP and port information from module addresses.

Constants:
    IP_REGEX: A regular expression pattern for matching IP addresses.
"""

import asyncio
import concurrent.futures
import re
import time
from functools import partial
import random
import requests
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import CountVectorizer
import Levenshtein

from communex.client import CommuneClient  # type: ignore
from communex.module.client import ModuleClient  # type: ignore
from communex.module.module import Module  # type: ignore
from communex.types import Ss58Address  # type: ignore
from substrateinterface import Keypair  # type: ignore
from fastapi import HTTPException
from comchat.models import get_service_class
from .services import service_and_models

from ._config import ValidatorSettings
from ..utils import log

IP_REGEX = re.compile(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d+")


def set_weights(
    settings: ValidatorSettings,
    score_dict: dict[
        int, float
    ],  # implemented as a float score from 0 to 1, one being the best
    # you can implement your custom logic for scoring
    netuid: int,
    client: CommuneClient,
    key: Keypair,
) -> None:
    """
    Set weights for miners based on their scores.

    Args:
        score_dict: A dictionary mapping miner UIDs to their scores.
        netuid: The network UID.
        client: The CommuneX client.
        key: The keypair for signing transactions.
    """

    # you can replace with `max_allowed_weights` with the amount your subnet allows
    score_dict = cut_to_max_allowed_weights(score_dict, settings.max_allowed_weights)

    # Create a new dictionary to store the weighted scores
    weighted_scores: dict[int, int] = {}

    # Calculate the sum of all inverted scores
    scores = sum(score_dict.values())

    # process the scores into weights of type dict[int, int] 
    # Iterate over the items in the score_dict
    for uid, score in score_dict.items():
        # Calculate the normalized weight as an integer
        weight = int(score * 1000 / scores)

        # Add the weighted score to the new dictionary
        weighted_scores[uid] = weight


    # filter out 0 weights
    weighted_scores = {k: v for k, v in weighted_scores.items() if v != 0}

    uids = list(weighted_scores.keys())
    weights = list(weighted_scores.values())
    # send the blockchain call
    client.vote(key=key, uids=uids, weights=weights, netuid=netuid)


def cut_to_max_allowed_weights(
    score_dict: dict[int, float], max_allowed_weights: int
) -> dict[int, float]:
    """
    Cut the scores to the maximum allowed weights.

    Args:
        score_dict: A dictionary mapping miner UIDs to their scores.
        max_allowed_weights: The maximum allowed weights (default: 420).

    Returns:
        A dictionary mapping miner UIDs to their scores, where the scores have been cut to the maximum allowed weights.
    """
    # sort the score by highest to lowest
    sorted_scores = sorted(score_dict.items(), key=lambda x: x[1], reverse=True)

    # cut to max_allowed_weights
    cut_scores = sorted_scores[:max_allowed_weights]

    return dict(cut_scores)


def extract_address(string: str):
    """
    Extracts an address from a string.
    """
    return re.search(IP_REGEX, string)


def get_subnet_netuid(client: CommuneClient, subnet_name: str = "replace-with-comchat"):
    """
    Retrieve the network UID of the subnet.

    Args:
        client: The CommuneX client.
        subnet_name: The name of the subnet (default: "foo").

    Returns:
        The network UID of the subnet.

    Raises:
        ValueError: If the subnet is not found.
    """

    subnets = client.query_map_subnet_names()
    for netuid, name in subnets.items():
        if name == subnet_name:
            return netuid
    raise ValueError(f"Subnet {subnet_name} not found")


def get_ip_port(modules_adresses: dict[int, str]):
    """
    Get the IP and port information from module addresses.

    Args:
        modules_addresses: A dictionary mapping module IDs to their addresses.

    Returns:
        A dictionary mapping module IDs to their IP and port information.
    """

    filtered_addr = {id: extract_address(addr) for id, addr in modules_adresses.items()}
    ip_port = {
        id: x.group(0).split(":") for id, x in filtered_addr.items() if x is not None
    }
    return ip_port


class TextValidator(Module):
    """
    A class for validating text generated by modules in a subnet.

    Attributes:
        client: The CommuneClient instance used to interact with the subnet.
        key: The keypair used for authentication.
        netuid: The unique identifier of the subnet.
        val_model: The validation model used for scoring answers.
        call_timeout: The timeout value for module calls in seconds (default: 60).

    Methods:
        get_modules: Retrieve all module addresses from the subnet.
        _get_miner_prediction: Prompt a miner module to generate an answer to the given question.
        _score_miner: Score the generated answer against the validator's own answer.
        get_miner_prompt: Generate a prompt for the miner modules.
        validate_step: Perform a validation step by generating questions, prompting modules, and scoring answers.
        validation_loop: Run the validation loop continuously based on the provided settings.
    """

    def __init__(
        self,
        key: Keypair,
        netuid: int,
        client: CommuneClient,
        call_timeout: int,
    ) -> None:
        super().__init__()
        self.client = client
        self.key = key
        self.netuid = netuid
        self.val_model = "foo"
        self.call_timeout = call_timeout

    def get_addresses(self, client: CommuneClient, netuid: int) -> dict[int, str]:
        """
        Retrieve all module addresses from the subnet.

        Args:
            client: The CommuneClient instance used to query the subnet.
            netuid: The unique identifier of the subnet.

        Returns:
            A dictionary mapping module IDs to their addresses.
        """

        # Makes a blockchain query for the miner addresses
        module_addreses = client.query_map_address(netuid)
        return module_addreses

    def _get_miner_prediction(
        self,
        service: str,
        model: str,
        question: str,
        miner_info: tuple[list[str], Ss58Address],
    ) -> str | None:
        """
        Prompt a miner module to generate an answer to the given question.

        Args:
            question: The question to ask the miner module.
            miner_info: A tuple containing the miner's connection information and key.

        Returns:
            The generated answer from the miner module, or None if the miner fails to generate an answer.
        """
        connection, miner_key = miner_info
        module_ip, module_port = connection
        client = ModuleClient(module_ip, int(module_port), self.key)
        try:
            start_time = time.time()
            # handles the communication with the miner
            miner_answer = asyncio.run(
                client.call(
                    "generate",
                    miner_key,
                    {
                        "service": service,
                        "model": model,
                        "prompt": question,
                    },
                    timeout=self.call_timeout,  # Â type: ignore
                )
            )
            
            end_time = time.time()
            response_time = end_time - start_time
            miner_answer["response_time"] = response_time

        except Exception as e:
            print(f"ðŸ”´ Miner {module_ip}:{module_port} failed to generate an answer", e)
            miner_answer = None
        return miner_answer


    def levenshtein_similarity(self, api_answer:str, miner_answer: str):
        distance = Levenshtein.distance(api_answer, miner_answer)
        similarity = 1 - (distance / max(len(api_answer), len(miner_answer)))
        
        return similarity
    
    def cosine_similarity(self, api_answer:str, miner_answer: str):
        vectorizer = CountVectorizer().fit_transform([api_answer, miner_answer])
        vectors = vectorizer.toarray()

        cos_sim = cosine_similarity(vectors)
        
        return cos_sim[0][1]
    
    def jaccard_similarity(self, api_answer:str, miner_answer: str):
        set1 = set(api_answer.split())
        set2 = set(miner_answer.split())
        
        intersection = set1.intersection(set2)
        union = set1.union(set2)
        similarity = len(intersection) / len(union)
        
        return similarity
    
    def tf_idf_similarity(self, api_answer:str, miner_answer: str):
        vectorizer = TfidfVectorizer().fit_transform([api_answer, miner_answer])
        vectors = vectorizer.toarray()

        cos_sim = cosine_similarity(vectors)
        
        return cos_sim[0][1]

    def _score_miner(self, api_answer:str, miner_answer: str, response_time: float):
        """
        Score the generated answer against the validator's own answer.

        Args:
            api_answer: The generated answer from the validator module.
            miner_answer: The generated answer from the miner module.

        Returns:
            The score assigned to the miner's answer.
        """

        # Implement your custom scoring logic here
        if not miner_answer:
            return 0
        
        try:
            levenshtein_similarity = self.levenshtein_similarity(api_answer, miner_answer)
            cosine_similarity = self.cosine_similarity(api_answer, miner_answer)
            jaccard_similarity = self.jaccard_similarity(api_answer, miner_answer)
            tf_idf_similarity = self.tf_idf_similarity(api_answer, miner_answer)
            
            similarity = (levenshtein_similarity + cosine_similarity + jaccard_similarity + tf_idf_similarity) / 4

            score = similarity * 0.7 + (1 / response_time) * 0.3
            print(f"ðŸŸ¢ Similarity: {similarity}, Response Time: {response_time}, Score: {score}")
            return score
        except Exception as e:
            print(f"Error in score the miners: {str(e)}")
            raise

    def get_miner_prompt(self, service: str, model: str) -> str:
        """
        Generate a prompt for the miner modules.

        Returns:
            The generated prompt for the miner modules.
        """
        
        url = "https://opentdb.com/api.php?amount=1&difficulty=hard"
        response = requests.get(url)
        if response.status_code == 200:
            data = response.json()
            question = data['results'][0]['question']
            return f"""
                        You are the AI assistant that uses the {model} model by {service}.
                        If not, provide an empty message.
                        If yes, please answer the following question:
                        {question}
                    """
        else:
            return None

    async def validate_step(
        self, syntia_netuid: int, settings: ValidatorSettings
    ) -> None:
        """
        Perform a validation step.

        Generates questions based on the provided settings, prompts modules to generate answers,
        and scores the generated answers against the validator's own answers.

        Args:
            syntia_netuid: The network UID of the subnet.
        """

        # retrive the miner information
        modules_adresses = self.get_addresses(self.client, syntia_netuid)
        modules_keys = self.client.query_map_key(syntia_netuid)
        val_ss58 = self.key.ss58_address
        if val_ss58 not in modules_keys.values():
            raise RuntimeError(f"validator key {val_ss58} is not registered in subnet")

        modules_info: dict[int, tuple[list[str], Ss58Address]] = {}

        modules_filtered_address = get_ip_port(modules_adresses)
        for module_id in modules_keys.keys():
            module_addr = modules_filtered_address.get(module_id, None)
            if not module_addr:
                continue
            modules_info[module_id] = (module_addr, modules_keys[module_id])

        score_dict: dict[int, float] = {}

        # Randomly choose ai service and model for miner prompt
        service = random.choice(list(service_and_models.keys()))
        model = random.choice(service_and_models[service])

        # Get answer from the miners
        prompt = None
        while prompt is None:
            prompt = self.get_miner_prompt(service, model)
            if prompt is None:
                print(f"Failed to fetch question from opentdb")
                time.sleep(1)
        get_miner_prediction = partial(self._get_miner_prediction, service, model, prompt)

        print(f"Selected the following miners: {modules_info.keys()}")

        with concurrent.futures.ThreadPoolExecutor(max_workers=16) as executor:
            it = executor.map(get_miner_prediction, modules_info.values())
            miner_answers = [*it]

        # Get api answer to compare it with miner response
        service_class = get_service_class(service)
        if not service_class:
            raise HTTPException(status_code=400, detail=f"Service not supported")

        service_instance = service_class(model)
        api_answer = service_instance.generate(prompt)
        
        def score_miner(uid, miner_response, api_answer):
            if not miner_response:
                print(f"Skipping miner {uid} that didn't answer")
                return uid, None

            miner_answer = miner_response["answer"]
            response_time = miner_response["response_time"]

            score = self._score_miner(api_answer, miner_answer, response_time)
            assert score <= 1
            return uid, score

        # Score the miners
        with concurrent.futures.ThreadPoolExecutor(max_workers=16) as executor:
            futures = [
                executor.submit(score_miner, uid, miner_response, api_answer)
                for uid, miner_response in zip(modules_info.keys(), miner_answers)
            ]
            
            for future in concurrent.futures.as_completed(futures):
                uid, score = future.result()
                if score is not None:
                    score_dict[uid] = score
                
        if not score_dict:
            print("No miner managed to give a valid answer")
            return None

        # the blockchain call to set the weights
        _ = set_weights(settings, score_dict, self.netuid, self.client, self.key)

    def validation_loop(self, settings: ValidatorSettings) -> None:
        """
        Run the validation loop continuously based on the provided settings.

        Args:
            settings: The validator settings to use for the validation loop.
        """

        while True:
            start_time = time.time()
            _ = asyncio.run(self.validate_step(self.netuid, settings))

            elapsed = time.time() - start_time
            if elapsed < settings.iteration_interval:
                sleep_time = settings.iteration_interval - elapsed
                print(f"ðŸŸ¡ Sleeping for {sleep_time}")
                time.sleep(sleep_time)
